# Note: This code is generated by Claude. I have not yet entirely understood it. 

import random
import numpy as np
from typing import List, Tuple, Dict

class BB84:
    """
    Implementation of the BB84 Quantum Key Distribution Protocol
    
    This simulates the quantum key exchange between Alice (sender) and Bob (receiver)
    with optional eavesdropping detection by Eve.
    """
    
    def __init__(self, key_length: int = 100):
        """
        Initialize BB84 protocol
        
        Args:
            key_length: Desired length of the final shared key
        """
        self.key_length = key_length
        self.alice_bits = []
        self.alice_bases = []
        self.bob_bases = []
        self.bob_measurements = []
        self.shared_key = []
        self.error_rate = 0.0
        
    def generate_random_bits(self, n: int) -> List[int]:
        """Generate n random bits (0 or 1)"""
        return [random.randint(0, 1) for _ in range(n)]
    
    def generate_random_bases(self, n: int) -> List[str]:
        """Generate n random measurement bases ('+' for rectilinear, 'x' for diagonal)"""
        bases = ['+', 'x']
        return [random.choice(bases) for _ in range(n)]
    
    def alice_prepare_qubits(self, bits: List[int], bases: List[str]) -> List[Dict]:
        """
        Alice prepares qubits based on her bits and chosen bases
        
        Encoding:
        - Rectilinear basis ('+'): |0⟩ for bit 0, |1⟩ for bit 1
        - Diagonal basis ('x'): |+⟩ for bit 0, |-⟩ for bit 1
        """
        qubits = []
        for bit, basis in zip(bits, bases):
            if basis == '+':  # Rectilinear basis
                state = '|0⟩' if bit == 0 else '|1⟩'
            else:  # Diagonal basis ('x')
                state = '|+⟩' if bit == 0 else '|-⟩'
            
            qubits.append({
                'bit': bit,
                'basis': basis,
                'state': state
            })
        return qubits
    
    def quantum_channel_with_noise(self, qubits: List[Dict], noise_rate: float = 0.0) -> List[Dict]:
        """
        Simulate quantum channel transmission with optional noise
        
        Args:
            qubits: List of prepared qubits
            noise_rate: Probability of bit flip during transmission (0.0 to 1.0)
        """
        transmitted_qubits = []
        for qubit in qubits:
            # Apply noise if specified
            if random.random() < noise_rate:
                # Bit flip noise
                flipped_bit = 1 - qubit['bit']
                if qubit['basis'] == '+':
                    new_state = '|0⟩' if flipped_bit == 0 else '|1⟩'
                else:
                    new_state = '|+⟩' if flipped_bit == 0 else '|-⟩'
                
                transmitted_qubits.append({
                    'bit': flipped_bit,
                    'basis': qubit['basis'],
                    'state': new_state
                })
            else:
                transmitted_qubits.append(qubit.copy())
        
        return transmitted_qubits
    
    def bob_measure_qubits(self, qubits: List[Dict], bob_bases: List[str]) -> List[int]:
        """
        Bob measures the received qubits using his randomly chosen bases
        
        Measurement outcomes:
        - Same basis as Alice: Deterministic result (matches Alice's bit)
        - Different basis: Random result (50% probability each)
        """
        measurements = []
        for qubit, bob_basis in zip(qubits, bob_bases):
            alice_basis = qubit['basis']
            alice_bit = qubit['bit']
            
            if alice_basis == bob_basis:
                # Same basis: measurement gives Alice's bit
                measured_bit = alice_bit
            else:
                # Different basis: random measurement outcome
                measured_bit = random.randint(0, 1)
            
            measurements.append(measured_bit)
        
        return measurements
    
    def sift_keys(self, alice_bits: List[int], alice_bases: List[str], 
                  bob_measurements: List[int], bob_bases: List[str]) -> Tuple[List[int], List[int]]:
        """
        Public basis comparison and key sifting
        
        Alice and Bob publicly compare their basis choices and keep only
        the bits where they used the same basis.
        """
        alice_sifted = []
        bob_sifted = []
        
        for a_bit, a_basis, b_bit, b_basis in zip(alice_bits, alice_bases, 
                                                  bob_measurements, bob_bases):
            if a_basis == b_basis:  # Same basis used
                alice_sifted.append(a_bit)
                bob_sifted.append(b_bit)
        
        return alice_sifted, bob_sifted
    
    def estimate_error_rate(self, alice_sifted: List[int], bob_sifted: List[int], 
                          sample_size: int = None) -> float:
        """
        Estimate quantum bit error rate (QBER) by comparing a subset of sifted keys
        """
        if sample_size is None:
            sample_size = min(len(alice_sifted) // 4, 50)  # Use 25% or max 50 bits
        
        if len(alice_sifted) < sample_size:
            sample_size = len(alice_sifted)
        
        # Randomly sample bits for error estimation
        indices = random.sample(range(len(alice_sifted)), sample_size)
        
        errors = 0
        for i in indices:
            if alice_sifted[i] != bob_sifted[i]:
                errors += 1
        
        error_rate = errors / sample_size if sample_size > 0 else 0.0
        
        # Remove sampled bits from the key (they're now public)
        remaining_indices = [i for i in range(len(alice_sifted)) if i not in indices]
        alice_remaining = [alice_sifted[i] for i in remaining_indices]
        bob_remaining = [bob_sifted[i] for i in remaining_indices]
        
        return error_rate, alice_remaining, bob_remaining
    
    def run_protocol(self, noise_rate: float = 0.0, eavesdropping: bool = False, 
                    verbose: bool = True) -> Dict:
        """
        Run the complete BB84 protocol
        
        Args:
            noise_rate: Channel noise rate (0.0 to 1.0)
            eavesdropping: Simulate Eve's intercept-resend attack
            verbose: Print protocol steps
            
        Returns:
            Dictionary containing protocol results
        """
        # Step 1: Alice generates random bits and bases
        # Generate more bits than needed to account for basis mismatches
        n_bits = self.key_length * 4  # Generate 4x more bits than needed
        self.alice_bits = self.generate_random_bits(n_bits)
        self.alice_bases = self.generate_random_bases(n_bits)
        
        if verbose:
            print(f"BB84 Quantum Key Distribution Protocol")
            print(f"=====================================")
            print(f"Target key length: {self.key_length}")
            print(f"Generated {n_bits} initial bits")
            print(f"Alice's first 10 bits: {self.alice_bits[:10]}")
            print(f"Alice's first 10 bases: {self.alice_bases[:10]}")
        
        # Step 2: Alice prepares qubits
        qubits = self.alice_prepare_qubits(self.alice_bits, self.alice_bases)
        
        # Step 3: Simulate eavesdropping if requested
        if eavesdropping:
            if verbose:
                print("\n⚠️  Eve is eavesdropping...")
            # Eve intercepts, measures randomly, and resends
            eve_bases = self.generate_random_bases(n_bits)
            eve_measurements = self.bob_measure_qubits(qubits, eve_bases)
            # Eve prepares new qubits based on her measurements
            qubits = self.alice_prepare_qubits(eve_measurements, eve_bases)
        
        # Step 4: Quantum channel transmission (with optional noise)
        transmitted_qubits = self.quantum_channel_with_noise(qubits, noise_rate)
        
        # Step 5: Bob chooses random bases and measures
        self.bob_bases = self.generate_random_bases(n_bits)
        self.bob_measurements = self.bob_measure_qubits(transmitted_qubits, self.bob_bases)
        
        if verbose:
            print(f"Bob's first 10 bases: {self.bob_bases[:10]}")
            print(f"Bob's first 10 measurements: {self.bob_measurements[:10]}")
        
        # Step 6: Public basis comparison and key sifting
        alice_sifted, bob_sifted = self.sift_keys(
            self.alice_bits, self.alice_bases, 
            self.bob_measurements, self.bob_bases
        )
        
        if verbose:
            print(f"\nAfter basis sifting: {len(alice_sifted)} matching bits")
            print(f"Alice sifted (first 10): {alice_sifted[:10]}")
            print(f"Bob sifted (first 10): {bob_sifted[:10]}")
        
        # Step 7: Error rate estimation
        self.error_rate, alice_final, bob_final = self.estimate_error_rate(
            alice_sifted, bob_sifted
        )
        
        # Step 8: Generate final shared key
        final_key_length = min(len(alice_final), self.key_length)
        alice_key = alice_final[:final_key_length]
        bob_key = bob_final[:final_key_length]
        
        if verbose:
            print(f"\nError rate estimation: {self.error_rate:.1%}")
            print(f"Final shared key length: {len(alice_key)}")
            print(f"Alice's key (first 20): {alice_key[:20]}")
            print(f"Bob's key (first 20): {bob_key[:20]}")
            
            # Security assessment
            if self.error_rate > 0.11:  # Theoretical threshold for BB84
                print("⚠️  HIGH ERROR RATE - Possible eavesdropping detected!")
                print("    Key exchange should be aborted.")
            elif self.error_rate > 0.05:
                print("⚠️  Elevated error rate - Channel may be compromised")
            else:
                print("✅ Low error rate - Channel appears secure")
        
        # Verify key agreement
        key_match = alice_key == bob_key
        
        return {
            'alice_key': alice_key,
            'bob_key': bob_key,
            'key_length': len(alice_key),
            'error_rate': self.error_rate,
            'key_agreement': key_match,
            'bits_generated': n_bits,
            'bits_after_sifting': len(alice_sifted),
            'sifting_efficiency': len(alice_sifted) / n_bits,
            'secure': self.error_rate <= 0.11
        }

# Example usage and testing
if __name__ == "__main__":
    print("BB84 Quantum Key Distribution - Example Usage")
    print("=" * 50)
    
    # Example 1: Normal operation (no noise, no eavesdropping)
    print("\n1. Normal BB84 Protocol (Ideal Channel)")
    print("-" * 40)
    bb84 = BB84(key_length=50)
    result1 = bb84.run_protocol(verbose=True)
    
    # Example 2: With channel noise
    print("\n\n2. BB84 with Channel Noise (5%)")
    print("-" * 40)
    bb84_noise = BB84(key_length=50)
    result2 = bb84_noise.run_protocol(noise_rate=0.05, verbose=True)
    
    # Example 3: With eavesdropping
    print("\n\n3. BB84 with Eavesdropping (Eve's Attack)")
    print("-" * 40)
    bb84_eve = BB84(key_length=50)
    result3 = bb84_eve.run_protocol(eavesdropping=True, verbose=True)
    
    # Summary
    print("\n\nSUMMARY")
    print("=" * 30)
    print(f"Normal channel - Error rate: {result1['error_rate']:.1%}, Secure: {result1['secure']}")
    print(f"Noisy channel  - Error rate: {result2['error_rate']:.1%}, Secure: {result2['secure']}")
    print(f"Eavesdropping  - Error rate: {result3['error_rate']:.1%}, Secure: {result3['secure']}")
    
    # Convert keys to strings for easy use
    print(f"\nFinal key from normal channel: {''.join(map(str, result1['alice_key']))}")